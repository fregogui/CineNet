<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="/d3"></script>
  <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
  <style>
  text {
    font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
  }
  svg {
    width: 100%;
  }
  .link {
    fill: none;
    stroke: #ddd;
    stroke-width: 1px;
  }
  .node {
    stroke: #000;
    stroke-width: 1px;
  }
  .tooltip {
    width: 300px;
    height: 300px;
    pointer-events: none;
    text-align: left;
    padding: 5px;
    font: 12px roboto;
    background: black  ;
    border: 1px;
    border-radius: 5px;
    color: #ECEFF1;
    opacity: 0.5;
  }
  .infos {
    text-align: left;
    padding: 5px;
    border: 2px solid black;
    float : right;
    vertical-align: top;
  }
  </style>
</head>

<body>
  <div>
    <input id="targetNode" name="targetNode" type="text" value="Enter the text" />
    <button onclick="search()">Search</button>
  </div>
  <script>
  var width =1000,
  height = 700,
  radius=35;
  var margin = 50;
  var r=12;
  var transition=500;
  var label="on"

  var color=d3.scaleOrdinal(d3.schemeCategory20)

  var main_div=d3.select("body").append("div");

  var infos=main_div.append("div").attr("class","infos").style("width","29%").style("height","1000px");
  // add the tooltip area to the webpage
  let tooltip = infos.append("div").attr("class", "tooltip").style("opacity", 0);
  // create an svg to draw in
  var svg = main_div.append("div").attr("class","chart").style("width","70%").style("height","1000px")
  .append("svg")
  .attr("viewBox", function(){return String(-width/2)+" "+String(-height/2)+" "+String(width)+" "+String(height)});

  var gradColor=svg.append("defs");

  //repartition d√©melage
  var simulation = d3.forceSimulation()
  .force("link", d3.forceLink().id(function(d) {return d.id; }).strength(0.025))//.distance(function(d,i){return i*5}).strength(1))
  .force("charge", d3.forceCollide().radius(35))
  //     .force("r", d3.forceRadial(function(d)  {return (19-color.domain().indexOf(d.nomination.award))*50;}))
  .force("center", d3.forceCenter(0,0))

  d3.json("/database.json", function(json) {


    var network=format_to_network(json);
    var awards=list_award(json);

    // set the nodes
    var nodes = network.nodes;
    // links between nodes
    var links = network.links;

    for (var i=0; i<links.length; i++) {
      if (i != 0 && links[i].source == links[i-1].source && links[i].target == links[i-1].target) {
        links[i].linknum = links[i-1].linknum + 1;
      }
      else {links[i].linknum = 1;};
    };

    // add the nodes to the simulation and
    // tell it what to do on each tick
    simulation
    .nodes(nodes)
    .on("tick", ticked);

    // add the links to the simulation
    simulation.force("link")
    .links(links);

    // on each tick, update node and link positions
    function ticked() {
      link.attr("d", positionLink);

      node.attr("cx", function (d) { return d.x=Math.max(-width/2+margin, Math.min(width/2 - margin, d.x)); })
      .attr("cy", function(d) { return d.y= Math.max(-height/2+margin, Math.min(height/2 - margin, d.y)); });
    }

    // add the curved links to our graphic
    var link = svg.append("g").attr("class","links").selectAll(".link")

    .data(links, function(d){
      return d.id;
    })
    .enter()
    .append("path")
    .attr("class", "link")
    .attr("id",function(d) {
      return d.id;
    })
    .style("stroke","grey")
    .style("stroke-width","0.7")
    .style("pointer-events", "none");
    /*
    var linktext = svg.append("g").selectAll(".linkname")
    .data(links, function(d){return d.id;});

    linktext.enter().append("g")
    .append("text")
    .attr("class", "linklabel")
    .style("font-size", "13px")
    .attr("x", "50")
    .attr("y", "-20")
    .attr("text-anchor", "start")
    .style("fill","#000")
    .append("textPath")
    .attr("xlink:href",function(d,i) { return "#" + d.id;})
    .text(function(d){return d.movie;});*/

    // add the nodes to the graphic
    var node = svg.append("g").attr("class","nodes").selectAll(".node")
    .data(nodes, function(d){
      return d.id;
    })
    .enter().append("circle")
    .attr("class", "node")
    .attr("r", r)
    .attr("id", function(d) { return "_" + d.id; })
    .attr("fill", function(d) {
      if (d.nomination.length>1) {
        return "url(#grad"+String(d.id)
      }
      else {
        return color(d.nomination[0].award);
      }
    })
    .attr('stroke', "black")
    .on("mouseover", mouse_on)
    .on("mouseout", mouse_out)
    .call(d3.drag()
    .on("start", dragstarted)
    .on("drag", dragged)
    .on("end", dragended));

    // links are drawn as curved paths between nodes
    function positionLink(d) {
      var offset = Math.pow(-1, d.linknum)*100/d.linknum;
      var midpoint_x = (d.source.x + d.target.x) / 2;
      var midpoint_y = (d.source.y + d.target.y) / 2;
      var dx = (d.target.x - d.source.x);
      var dy = (d.target.y - d.source.y);
      var normalise = Math.sqrt((dx * dx) + (dy * dy));
      var offSetX = midpoint_x + offset*(dy/normalise);
      var offSetY = midpoint_y - offset*(dx/normalise);
      var source_x=Math.max(-width/2+margin, Math.min(width/2 - margin, d.source.x));
      var source_y=Math.max(-height/2+margin, Math.min(height/2 - margin, d.source.y));
      var target_x=Math.max(-width/2+margin, Math.min(width/2 - margin, d.target.x));
      var target_y=Math.max(-height/2+margin, Math.min(height/2 - margin, d.target.y))
      return "M" + source_x + "," + source_y +
      "S" + offSetX + "," + offSetY +
      " " + target_x + "," + target_y;
    }

    function restart(data_to_remove) {
      //update nodes (remove or add)
      node = node.data(network.nodes.filter(function(l){return !data_to_remove.nodes.includes(l.id)}), function(d) { return d.id;});
      node.exit().remove();
      var newNode = node.enter().append("circle")
      .attr("class", "node")
      .attr("r", r)
      .attr("id", function(d) { return "_" + d.id; })
      .attr("fill", function(d){
        return color(d.nomination[0].award)
      })
      .attr('stroke', "black")
      .on("mouseover", mouse_on)
      .on("mouseout",mouse_out)
      .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended))

      node = node.merge(newNode);

      //update links (remove or add)

      link = link.data(network.links.filter(function(l){return !data_to_remove.links.includes(l.id)}), function(d) { return d.id;});
      link.exit().remove();
      newLink = link.enter()
      .append("path")
      .attr("class", "link")
      .attr("id",function(d) {
        return d.id;
      })
      .style("stroke","grey")
      .style("stroke-width","0.7")
      .style("pointer-events", "none");
      ;
      link = link.merge(newLink);

      //restart forces
      simulation.force("link").links(network.links.filter(function(l){return !data_to_remove.links.includes(l.id)}));
      simulation.force("charge", d3.forceCollide().radius(45));
      simulation.force("center", d3.forceCenter(0,0));
      //simulation.on("tick",ticked);
      simulation.alpha(0.5).alphaTarget(0).restart();
    }

    function dragstarted(d) {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }

    function dragended(d) {
      if (!d3.event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    function mouse_on(d){
      node_display=[];
      simulation.stop();
      tooltip.transition()
      .duration(transition)
      .style("opacity", 0.5);
      tooltip.html(html_tooltip(d))
      .style("background", function() {
        if (d.nomination.length>1) {
          return "black";
        }
        else {
          return color(d.nomination[0].award);
        }
      })
      .style("height",function(){
        n=d.nomination.length
        if (n<2){
          a=d.nomination[0].award.length+d.nomination[0].movie.length+3;
          count=(a-a%50)/50+1+6; // Nombre de lignes des awards
        }
        else{
          count=0;
          for (var i=0;i<n;i++){
            a=d.nomination[i].movie.length+d.nomination[i].award.length+3;
            count=count+(a-a%50)/50+2;
          }
          count=count+3+2;
        }
        return String(count*12)+'px'
      })
      .style("left", "5px")
      .style("top", "15px");
      name_mouse=d.name;
      d3.selectAll("circle").style("opacity", .1);

      d3.select("#_" + d.id).attr("r", 30).style("opacity",1)
      .transition().attr("r", r);
      d3.selectAll(".link").style("opacity", .05);
      touchID=d.id;
      textDisplay=svg.append("g").attr("class", "nodetext");
      linktext = svg.append("g").attr('class',"linktext").selectAll(".linkname")
      .data(links.filter(function(d){return d.source.id === touchID || d.target.id === touchID}), function(d){return d.id;});

      svg.selectAll(".link")
      .filter(function(d) {
        if(d.source.id === touchID || d.target.id === touchID) {
          d3.selectAll("circle").filter(function(f) {
            if(d.source.id === f.id ||  d.target.id === f.id) {
              name_node=f.name;
              if (name_node!=name_mouse) {
                if (!node_display.includes(name_node)){
                  xC=parseFloat(d3.select(this).attr("cx"))+r+1;
                  yC=parseFloat(d3.select(this).attr("cy"))+4;
                  id=parseFloat(d3.select(this).attr("id"));
                  textDisplay.append("text")
                  .attr("x",xC)
                  .attr("y",yC)
                  .attr("pointer-events","none")
                  .text(function(f){return name_node;})
                  node_display.push(name_node);
                }
              }
              return true;
            }
          })
          .style("opacity", 1);

          if(label==="on") {
            path=(d3.select(this).attr("d")).split(",");

            xA=parseFloat(path[0].split("M")[1]);
            xB=parseFloat(path[2].split(" ")[1]);
            yA=parseFloat(path[1].split("S")[0]);
            yB=parseFloat(path[3]);
            xT=xA+(xB-xA)/2.0;
            yT=yA+(yB-yA)/2.0;
            movieT=d.movie;
            theta=(180.0/Math.PI)*Math.acos(Math.abs(xB-xA)/Math.sqrt((yB-yA)*(yB-yA)+(xB-xA)*(xB-xA))/2.0);
            linktext.enter().append("g")
            .append("text")
            .attr("class", "linklabel")
            .style("font-size", "13px")
            .attr("x", "50")
            .attr("y", "-20")
            .attr("text-anchor", "start")
            .style("fill","#000")
            .append("textPath")
            .attr("xlink:href",function(d,i) { return "#" + d.id;})
            .text(function(d){return d.movie;})
            .style("pointer-events","none");
          }

          /*  textDisplay.append("text")

          .attr("x",xT)
          .attr("y",yT)

          .attr("pointer-events","none")
          .text(function(d){return movieT});*/
          return true;
        }
      })
      .style("stroke","black")
      .style("stroke-width","3")
      .style("opacity", 1);
    }

    function mouse_out() {
      tooltip.transition()
      .duration(transition)
      .style("opacity", 0);

      d3.selectAll("circle").style("opacity",1).attr("r",r);
      d3.selectAll(".link").style("opacity",1).style("stroke","grey").style("stroke-width","0.7");
      svg.selectAll(".nodetext").remove();
      svg.selectAll(".linktext").remove();
      simulation.restart();
    }

    function mouse_on_legend(d) {
      node_display=[];
      if(d3.select(this).style("fill-opacity")==1){
        award_mouse=d;
        textDisplay=svg.append("g").attr("class", "text_link")
        simulation.stop();
        d3.selectAll("circle")
        .transition()
        .duration(transition).style("opacity", .1);
        d3.selectAll(".link")
        .transition()
        .duration(transition).style("opacity", .1);
        svg.selectAll("circle")
        .filter( function(d){
          var searchNomination = d.nomination.filter( nomination => { return nomination.award === award_mouse; });
          if (searchNomination.length !== 0){
            if (!node_display.includes(d.name)){
              xC=parseFloat(d3.select(this).attr("cx"))+r+1;
              yC=parseFloat(d3.select(this).attr("cy"))+4;
              id=parseFloat(d3.select(this).attr("id"));

              textDisplay.append("text")
              .attr("x",xC)
              .attr("y",yC)
              .attr("pointer-events","none")
              .text(function(){
                return d.name;
              })
              .style("opacity",0)
              .transition()
              .duration(transition)
              .style("opacity",1);
              node_display.push(d.name);
            }
            return true;
          }
        })
        .transition()
        .duration(transition)
        .style("opacity", 1);

        svg.selectAll(".link")
        .filter(function(d) {
          var searchNominationInSource = d.source.nomination.filter( nomination => { return nomination.award === award_mouse; });
          var searchNominationInTarget = d.target.nomination.filter( nomination => { return nomination.award === award_mouse; });
          if(searchNominationInSource.length !== 0 || searchNominationInTarget.length !== 0) {
            d3.selectAll("circle").filter(function(f) {
              if(d.source.id === f.id ||  d.target.id === f.id) {
                var searchNomination = f.nomination.filter( nomination => { return nomination.award !== award_mouse; });
                if (searchNomination.length !== 0) {
                  if (!node_display.includes(f.name)){
                    xC=parseFloat(d3.select(this).attr("cx"))+r+1;
                    yC=parseFloat(d3.select(this).attr("cy"))+4;
                    id=parseFloat(d3.select(this).attr("id"));
                    textDisplay.append("text")
                    .attr("x",xC)
                    .attr("y",yC)
                    .attr("pointer-events","none")
                    .text(function(){
                      return f.name;
                    })
                    .style("opacity",0)
                    .transition()
                    .duration(transition)
                    .style("opacity",1);
                    node_display.push(f.name);
                  }
                  return true;
                }
              }
            })
            .transition()
            .duration(transition)
            .style("opacity", 1);
            return true;
          }
        })
        .transition()
        .duration(transition)
        .style("stroke","black")
        .style("stroke-width","1")
        .style("opacity", 1);
      }
    }

    function mouse_out_legend() {
      d3.selectAll("circle").transition()
      .duration(transition).style("opacity",1).attr("r",r);
      d3.selectAll(".link").transition()
      .duration(transition).style("opacity",1).style("stroke","grey").style("stroke-width","0.7");
      svg.selectAll(".text_link").remove();
      simulation.restart();
    }

    /* init an array in which we want to store nodes we will delete*/
    var data_to_remove ={"nodes":[],"links":[]};

    var all=infos.append("svg").attr("height","5%");

    all.append("rect")
    .attr("x", 1)
    .attr("y",1)
    .attr("width", 18)
    .attr("height", 18)
    .attr("fill", 'black')
    .attr("stroke",'black')
    .attr("stroke-width",2)
    .style("fill-opacity",1)
    .on("click", function(d){
      if (d3.select(this).style("fill-opacity")==1) {

        d3.selectAll("rect").style("fill-opacity",0.1);
        for (var i=0;i<network.nodes.length;i++){
          data_to_remove.nodes.push(network.nodes[i].id)
        }

        data_to_remove.links=[];
        for (var k=0;k<data_to_remove.nodes.length;k++){
          for (var j=0;j<network.links.length;j++){
            if(network.links[j].source.id===data_to_remove.nodes[k] || network.links[j].target.id===data_to_remove.nodes[k]){
              data_to_remove.links.push(network.links[j].id);
            }
          }
        }
      }
      else {
        data_to_remove ={"nodes":[],"links":[]};
        d3.selectAll("rect").style("fill-opacity",1);
      }
      restart(data_to_remove);
    });

    all.append("text")
    .attr("x", 25)
    .attr("y",10)
    .attr("dy", ".35em")
    .style("text-anchor", "left")
    .text("All")
    //active label :
    var label_activation=infos.append("svg").attr("height","5%");

    label_activation.append("rect")
    .attr("x", 1)
    .attr("y",1)
    .attr("width", 18)
    .attr("height", 18)
    .attr("fill", 'black')
    .attr("stroke",'black')
    .attr("stroke-width",2)
    .style("fill-opacity",1)
    .on("click", function(d){
      if (d3.select(this).style("fill-opacity")==1) {
        d3.select(this).style("fill-opacity",0);
        label="off"
      }
      else {
        label="on"
        d3.select(this).style("fill-opacity",1);
      }
    });

    label_activation.append("text")
    .attr("x", 25)
    .attr("y",10)
    .attr("dy", ".35em")
    .style("text-anchor", "left")
    .text("Label on links")
    // draw legend
    var legend = infos.append("svg").attr("height","60%").selectAll(".legend")
    .data(awards)
    .enter().append("g")
    .attr("class", "legend")
    .attr("transform", (d, i) => { return "translate(0," + i * 22 + ")"; });

    // draw legend colored rectangles
    legend.append("rect")
    .attr("x", 1)
    .attr("y",0)
    .attr("width", 18)
    .attr("height", 18)
    .attr("fill", color)
    .attr("stroke",color)
    .attr("stroke-width",2)
    .style("fill-opacity",1)
    .on("click", function(d){
      if (d3.select(this).style("fill-opacity")==1) {
        d3.select(this).style("fill-opacity",0.1)
      }
      else {
        d3.select(this).style("fill-opacity",1)
      }
      for (var i=0;i<network.nodes.length;i++){
        if (network.nodes[i].nomination[0].award===d){
          if (data_to_remove.nodes.includes(network.nodes[i].id)){
            data_to_remove.nodes.splice(data_to_remove.nodes.indexOf(network.nodes[i].id),1);
          }
          else {
            data_to_remove.nodes.push(network.nodes[i].id)
          }
        }
      }
      data_to_remove.links=[];
      for (var k=0;k<data_to_remove.nodes.length;k++){
        for (var j=0;j<network.links.length;j++){
          if(network.links[j].source.id===data_to_remove.nodes[k] || network.links[j].target.id===data_to_remove.nodes[k]){
            data_to_remove.links.push(network.links[j].id);
          }
        }
      }
      restart(data_to_remove);

    })
    .on("mouseover", mouse_on_legend)
    .on("mouseout", mouse_out_legend);

    // draw legend text
    legend.append("text")
    .attr("x", 25)
    .attr("y",6)
    .attr("dy", ".35em")
    .style("text-anchor", "left")
    .text(d => { return d;})

    function html_tooltip(node){
      n=node.nomination.length
      if (n<2){
        text=`<p><b>Name : </b>${node.name}</p>`+`<p><b>Nomination : </b></p>`+`<p>&emsp;${node.nomination[0].award} : ${node.nomination[0].movie}</p>`

      }
      else{
        console.log("hey")
        text=`<p><b>Name : </b>`+node.name+`</p>`+`<p><b>Films : </b></p>`
        for (var i=0;i<n;i++){
          current_movie=node.nomination[i].movie;
          current_award=node.nomination[i].award
          text=text+`<p>&emsp;`+current_award+` : `+current_movie+`</p>`
        }
      }
      return text
    }
    
    multicolor(network)
    function multicolor(data){
      for (var i=0;i<data.nodes.length;i++){
        if (data.nodes[i].nomination.length==2){
        foo=gradColor.append("linearGradient")
            .attr("id",function(){return "grad"+String(data.nodes[i].id);})
            .attr("x1", "100%").attr("x2", "0%").attr("y1", "0%").attr("y2", "0%")
            foo.append("stop").attr("offset", "50%").style("stop-color", function(){return color(data.nodes[i].nomination[0].award)});
            foo.append("stop").attr("offset", "50%").style("stop-color", function(){return color(data.nodes[i].nomination[1].award)});
        }
        else if (data.nodes[i].nomination.length==3){
        foo=gradColor.append("linearGradient")
            .attr("id",function(){return "grad"+String(data.nodes[i].id);})
            .attr("x1", "100%").attr("x2", "0%").attr("y1", "0%").attr("y2", "0%")
            foo.append("stop").attr("offset", "50%").style("stop-color", function(){return color(data.nodes[i].nomination[0].award)});
            foo.append("stop").attr("offset", "50%").style("stop-color", function(){return color(data.nodes[i].nomination[1].award)});
        }
      }

    }
  });

  function format_to_network(data){
    n=data.length;
    network={"nodes":[],"links":[]}
    for (var i=0;i<n;i++){
      actor={};
      actor.name=data[i].name;
      actor.id=data[i].id;

      actor.nomination=data[i].nomination;
      network.nodes.push(actor);
      credtis_i=[];
      credits_i=data[i].credits.crew.concat(data[i].credits.cast);
      movies_i=[];
      for (var j=i+1;j<n;j++){
        movies_j=[];
        credits_j= data[j].credits.crew.concat(data[j].credits.cast);
        for (var l=0;l<credits_i.length;l++){
          for (var m=0;m<credits_j.length;m++){
            if (movies_i.includes(credits_i[l].id)==false && movies_j.includes(credits_j[m].id)==false && credits_i[l].id===credits_j[m].id){
              link={};
              movies_i.push(credits_i[l].id);
              movies_j.push(credits_j[m].id);
              link.source=data[i].id;
              link.target=data[j].id;
              link.movie=credits_i[l].original_title;
              link.movie_id=credits_i[l].id;
              link.id=data[i].id+""+data[j].id+""+credits_i[l].id;
              network.links.push(link);
            }
          }
        }
      }
    }
    return network;
  }

  function search() {
    d3.selectAll("circle")
    .style("opacity", .1);
    d3.selectAll(".link")
    .style("opacity", .1);

    var userInput = document.getElementById("targetNode");

    var theNode = d3.selectAll('circle').filter(function(d) {
      return d.name === userInput.value
    })
    .transition()
    .duration(transition)
    .style("opacity", 1)
    .attr('fill', function(d){
      return color(d.nomination[0].award)
    });
  }

  function list_award(data){
    output=[];
    for (var i=0;i<data.length;i++){
      if (!output.includes(data[i].nomination[0].award)){
        output.push(data[i].nomination[0].award);
      }
    }
    return output;
  }

  Array.prototype.diff = function(a) {
    return this.filter(function(i) {
      return a.indexOf(i) < 0;
    });
  };

</script>
</body>
